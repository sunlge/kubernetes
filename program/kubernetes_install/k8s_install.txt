K8s中文社区文档：
	http://docs.kubernetes.org.cn/230.html
 
官方网站：
	https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/
	
GitHub有源码地址和release地址
	https://github.com/kubernetes/kubernetes/
	
https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.13.md 对应下载地址

阿里的官方文档：
	https://help.aliyun.com/document_detail/25975.html?spm=5176.54417.668253.btn21cs.637f2459l0k0Mx


单词:
	舵手：kubernetes
	
kubeadm config images list	##获取k8s所需版本镜像
	
	
云原生：
	在一般用法中，“云原生”是一种构建和运行应用程序的方法，它利用了云计算交付模型的优势。“云原生”是关于如何创建和部署应用程序，和位置无关。 这意味着应用程序位于云中，而不是传统数据中心。
	
kubernetes设计理念：
	API设计原则
		声明式的
	控制机设计原则
	
DevOps是什么？
	一种文化和思想，将运维开发产品更好的柔和到一起。参考下列内容
	CI：持续集成
		项目上线之前：
			做方案，计划 --> 架构设计 --> 开发 --> 构建 --> 测试
				开发代码之后的过程称之为CI
				构建过程可以通过工具完成，所谓的maven之类的工具
				
		单元测试：
			开发者自测代码，保证各自的代码能够正常工作
			
	CD：持续交付，Delivery
		将测试好以后打包的最终产品自动实现交给运维就是持续交付
		
	CD：持续部署，Deployment
		自动将产品进行上线或投入生产环境中称之为CD。

命令式：
	返回结果，命令执行成功之后才会返回结果
声明使：
	不需要结果，你只需要声明你所期望的状态就好。


相关概念网址：
	https://help.aliyun.com/document_detail/25975.html?spm=5176.54417.668253.btn21cs.637f2459l0k0Mx

Kubernetes：
	自动装箱，自动修复，水平扩展，服务发现和负载均衡，自动发布和回滚
	密钥和配置管理，存储编排，批量处理执行任务
	通过http或者https的一个API接口对外提供服务
	
相关概念：		
	Pod：
		k8s中最小的调度逻辑单元，一个Pod封装多个应用容器（也可以只有一个容器）、存储资源、一个独立的网络 IP 以及管理控制容器运行方式的策略选项。
	
		Pod，Label，Label Selector 标签选择器
			Label：key=value
			Label Selector：
		
		Pod：(有生命周期的对象)
			自主式Pod
			控制器管理的Pod
				ReplicationController(副本控制器)
			
		一个Pod可以拥有多个容器，共享同一个底层的网络名称空间
			Net UTS IPC这是共享的，下面是互相隔离的
			
			互相隔离：
				User Mount PID 
		
		还可以去共享存储卷；
		
		需要在Pod上放多个容器时；
			主容器，相当于一个Pod上的master(程序)
			辅助的容器，去辅助主容器(程序)完成工作。
		
		一个Pod里的所有容器只能运行在一个node上的这个Pod里。	
			
		为了实现Pod的识别，需要在Pod之上附加一些元数据；	
			拥有一个类似于一个Key值，这个Key值必须是value的这种概念。否则就不是这个Pod。
				根据selector(标签选择器去选择)
		
			
			六种中名称空间：
				UTS：		主机名和域名
				IPC：		信号量，消息队列和共享内存
				PID：		进程编号
				Network：	网络设备，网络栈，端口等
				Mount：		挂载点(文件系统)
				User：		用户和用户组	
		
	副本控制器(Replication Controller，RC)
		RC 确保任何时候 Kubernetes 集群中有指定数量的 pod 副本(replicas)在运行。通过监控运行中的 Pod 来保证集群中运行指定数目的 Pod 副本。指定的数目可以是多个也可以是1个；少于指定数目，RC 就会启动运行新的 Pod 副本；多于指定数目，RC 就会终止多余的 Pod 副本。
		
	副本集（Replica Set，RS）
		ReplicaSet（RS）是 RC 的升级版本，唯一区别是对选择器的支持，RS 能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为 Deployment 的理想状态参数使用。

		
	部署（Deployment）
		部署表示用户对 Kubernetes 集群的一次更新操作。部署比 RS 应用更广，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的 RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧 RS 中的副本数减小到 0的复合操作；这样一个复合操作用一个RS是不太好描述的，所以用一个更通用的 Deployment 来描述。不建议您手动管理利用 Deployment 创建的 RS。

	服务（Service）
		Service 也是 Kubernetes 的基本操作单元，是真实应用服务的抽象，每一个服务后面都有很多对应的容器来提供支持，通过 Kube-Proxy 的 port 和服务 selector 决定服务请求传递给后端的容器，对外表现为一个单一访问接口，外部不需要了解后端如何运行，这给扩展或维护后端带来很大的好处。

	标签（labels）
		Labels 的实质是附着在资源对象上的一系列 Key/Value 键值对，用于指定对用户有意义的对象的属性，标签对内核系统是没有直接意义的。标签可以在创建一个对象的时候直接赋予，也可以在后期随时修改，每一个对象可以拥有多个标签，但 key 值必须唯一。

	存储卷（Volume）
		Kubernetes 集群中的存储卷跟 Docker 的存储卷有些类似，只不过 Docker 的存储卷作用范围为一个容器，而 Kubernetes 的存储卷的生命周期和作用范围是一个 Pod。每个 Pod 中声明的存储卷由 Pod 中的所有容器共享。支持使用 Persistent Volume Claim 即 PVC 这种逻辑存储，使用者可以忽略后台的实际存储技术，具体关于 Persistent Volumn(pv)的配置由存储管理员来配置。

	持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）
		PV 和 PVC 使得 Kubernetes 集群具备了存储的逻辑抽象能力，使得在配置 Pod 的逻辑里可以忽略对实际后台存储技术的配置，而把这项配置的工作交给 PV 的配置者。存储的 PV 和 PVC 的这种关系，跟计算的 Node 和 Pod 的关系是非常类似的；PV 和 Node 是资源的提供者，根据集群的基础设施变化而变化，由 Kubernetes 集群管理员配置；而 PVC 和 Pod是资源的使用者，根据业务服务的需求变化而变化，由 Kubernetes 集群的使用者即服务的管理员来配置。

	Ingress
		Ingress 是授权入站连接到达集群服务的规则集合。你可以通过 Ingress 配置提供外部可访问的 URL、负载均衡、SSL、基于名称的虚拟主机等。用户通过 POST Ingress 资源到 API server 的方式来请求 ingress。 Ingress controller 负责实现 Ingress，通常使用负载均衡器，它还可以配置边界路由和其他前端，这有助于以 HA 方式处理流量。
		
k8s_master组件：
	API Server：
		负责接受、解析、处理请求；
	Scheduler
		调度器，调度每一个容器创建的请求
			观测每一个node的总共可用的CPU，RAM存储资源，根据容器的所需资源的最低资源来评估哪一个node节点合适
		
		两级调度：
			预选，评估每一个node有几个符合
			优选，评估出来后选择最佳
	
	controller-manager
		控制器管理器，确保控制器处于健康状态；
		
node_组件：
	kubelet：
		集群代理
		Scheduler调度的结果由kubelet执行，启动Pod，本机管理Pod
		接受任务，在本机试图启动容器，因为运行容器需要docker来执行
		
	kube-proxy
		负责随时与API-Server进行通信
		
	docker
		容器引擎
	RKT
	supervisord
	fluentd
	
K8s网络：
	节点网络
	集群网络
	Pod 网络
	
CNI：接入外部的网络服务解决方案
	flannel：网络配置
	calico：网络配置，网络策略；
	canel：两者结合体
·		

###Docker Hub上的
	mirrorgooglecontainers存有最新k8s的镜像
	
kubeadm
	1.master，nodes：安装kubelet，kubeadm，docker
	2.master：kubeadm init
	3.nodes：kubeadm join
可以参照文档
	https://github.com/kubernetes/kubeadm/tree/master/docs/design
	
k8s分布式部署：//单一的master节点

https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/

##配置yum节点，阿里的
[root@k8s1 yum.repos.d]# vim k8s.repo 
[kubernetes]
name=k8s Repo
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
enabled=1

##解决密钥报错问题
[root@k8s1 ~]# wget https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
[root@k8s1 ~]# rpm --import yum-key.gpg
[root@k8s1 ~]# wget https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg

##安装配置	
kubelet 的主要功能就是
	定时从某个地方获取节点上 pod/container 的期望状态（运行什么容器、运行的副本数量、网络或者存储如何配置等等），并调用对应的容器平台接口达到这个状态
	集群状态下，kubelet 会从 master 上读取信息，但其实 kubelet 还可以从其他地方获取节点的 pod 信息。目前 kubelet 支持三种数据源：
		本地文件
		通过 url 从网络上某个地址来获取信息
		API Server：从 kubernetes master 节点获取信息
		
kubectl 的主要功能就是管理集群
		
[root@k8s1 ~]# yum -y  install docker-ce-18.09.3 kubelet-1.14.0-0  kubeadm-1.14.0-0 kubectl-1.14.0-0

[root@master ~]# vim /etc/docker/daemon.json
{
  "registry-mirrors": ["https://nw1puivx.mirror.aliyuncs.com"]
  "exec-opts": ["native.cgroupdriver=systemd"],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m"
  },
  "storage-driver": "overlay2",
  "storage-opts": [
    "overlay2.override_kernel_check=true"
  ]
}

Service模型：
	userspace 	1.1-
		依赖于Iptables。
	iptables 	1.10-
	IP_vs 		1.10+
		需要添加专门的选项，如果没有则自动降级为Iptables。
		编辑Kubelet的配置文件/etc/sysconfig/kubelet
			KUBE_PROXY_MODE=ipvs
			
#加载模块
[root@master ~]# modprobe br_netfilter
#使用Ip_vs
	modprobe ip_vs
	modprobe ip_vs_rr
	modprobe ip_vs_wrr
	modprobe ip_vs_sh
	modprobe nf_conntrack_ipv4

[root@k8s1 ~]# cat /proc/sys/net/bridge/bridge-nf-call-ip6tables 
1
[root@k8s1 ~]# cat /proc/sys/net/bridge/bridge-nf-call-iptables 
1

##额外步骤--错误的
[root@master ~]# vim /usr/lib/systemd/system/docker.service
ExecStart=/usr/sbin/iptables -p FORWRD ACCEPT


##自己装镜像，可以不做省略下步骤。
[root@k8s1 ~]# vim /usr/lib/systemd/system/docker.service 
Environment="HTTPS_PROXY=http://www.ik8s.io:10080"
Environment="NO_PROXY=127.0.0.0/8,192.168.100.0/24"

##生成配置文件		
[root@k8s1 ~]# rpm -ql kubelet
##清单目录 /etc/kubernetes/manifests
##配置文件 /etc/sysconfig/kubelet
##untli file /etc/systemd/system/kubelet.service
##主程序   /usr/bin/kubelet

##kubelet在集群init时才可以启动
[root@k8s1 ~]# systemctl start kubelet
[root@k8s1 ~]# systemctl status kubelet
[root@k8s1 ~]# systemctl stop kubelet
[root@k8s1 ~]# systemctl enable !$
[root@k8s1 ~]# systemctl enable docker
[root@k8s1 ~]# systemctl start !$

##初始化
[root@k8s1 ~]# kubeadm init --help

--apiserver-advertise-address string  ##自己的监听地址
--apiserver-bind-port int32	      ##监听端口，默认6443
--cert-dir string                     ##加载证书文件目录 
--config string			      ##加载配置文件

[root@k8s1 ~]# cat /etc/sysconfig/kubelet
KUBELET_EXTRA_ARGS="--fail-swap-on=false" ##swap开启时不让其出错

[root@k8s1 ~]# kubeadm init --kubernetes-version=v1.14.0 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap 

##关于绑定网卡问题：
	https://k8smeetup.github.io/docs/reference/setup-tools/kubeadm/kubeadm-init
	
当运行 init 时，您必须保证指定一个内部 IP 作为 API server 的绑定地址，例如：
	kubeadm init --apiserver-advertise-address=<private-master-ip>

当工作 node 配置好后，添加一个指定工作 node 私有 IP 的参数到 /etc/systemd/system/kubelet.service.d/10-kubeadm.conf 中：
	--node-ip=<private-node-ip>

##可以去/etc/fstab中注释点swap分区
	并且使用 
		swapoff -a 临时关闭


##初始化时，下面几个镜像是必须的
##使用命令 kubeadm config images list 查看
	k8s.gcr.io/kube-proxy 
	k8s.gcr.io/kube-apiserver          
	k8s.gcr.io/kube-controller-manager   
	k8s.gcr.io/kube-scheduler           
	k8s.gcr.io/etcd       
	k8s.gcr.io/pause 

关于获取镜像的问题：
	https://blog.csdn.net/shida_csdn/article/details/78480241
	
##全部装载完成之后：
	会监听一个6443的端口

##暂时保存一下	
kubeadm join 192.168.100.141:6443 --token azxxhb.g5yoxis2utyq5qjl --discovery-token-ca-cert-hash sha256:f4c67847488d4bdbd166ead4367598f115ca961b44ebc3836e89fc9c1594d442 --ignore-preflight-errors=Swap
	过期后创建新的：
		https://blog.csdn.net/mailjoin/article/details/79686934

##下面的命令会自动重新生成一个token，并且产生一条命令。生成以后直接复制即可。	
kubeadm token create --print-join-command


kubeadm join 192.168.100.10:6443 --token diytzd.hnivfvkb6ursbqhq \
    --discovery-token-ca-cert-hash sha256:b12e4eaefd11445f698b164a3e56fd2a89657c30a8cf3246af01d843fc86d278 


##节点安装
[root@k8s2 ~]# yum -y install docker-ce-18.09.3 kubelet-1.14.0-0 kubeadm-1.14.0-0  //kubectl(可选_执行客户端程序)
[root@node1 docker]# systemctl enable kubelet
[root@node1 docker]# systemctl enable docker	
[root@node1 docker]# systemctl start  docker
	
	
	
部署：flannel
	官方文档建议：
		https://github.com/coreos/flannel

##master上执行
执行一条命令：
	最好先将yml文件下载下来，之后在用apply去声明它。
	kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
	由于flannel使用默认路由的网卡接口，导致适用了外网网卡，致使pod之间无法访问。
	所以需要指定使用相应网卡。在command参数增加--iface=eth1即可，具体配置如下
		  command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        - --iface=eth1


高级调度节点特性：
	节点亲和性/反亲和性特性、Pod亲和性/反亲和性特性、污点和容忍特性、报告节点问题特性。
	
污点和容忍：
	污点和容忍（Taints and tolerations）在一起工作，目的是确保Pod不会被调度到不正确的节点上。通过给节点设置污点，可以标识出这些节点不接受任何Pod，这些Pod不能容忍任何污点。也可以通过给Pod设置容忍，让这些Pod部署到能够容忍污点的节点上。
	
API server组件：	
	在 kubernetes 集群中，API Server 有着非常重要的角色。API Server 负责和 etcd 交互（其他组件不会直接操作 etcd(DB)，只有 API Server 这么做），是整个 kubernetes 集群的数据中心，所有的交互都是以 API Server 为核心的。简单来说，API Server 提供了一下的功能：

	整个集群管理的 API 接口：所有对集群进行的查询和管理都要通过 API 来进行集群内部各个模块之间通信的枢纽：所有模块之前并不会之间互相调用，而是通过和 API Server 打交道来完成自己那部分的工作
	
k8s核心概念：
	http://www.cnblogs.com/zhenyuyaodidiao/p/6500720.html
	

Deployments是kubernetes中的一种控制器，是比ReplicaSet更高级的概念，它最重的特性是支持对pod与ReplicaSet的声明式升级，声明式升级比其它方式的升级更安全可靠。需要注意的是用户不应该手动管理被Deployments创建的ReplicaSet。

关于ReplicaSet：
	https://blog.csdn.net/denglelai123/article/details/80845875
